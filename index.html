<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>1.2 functions — Domain · Range · Onto</title>
  <link rel="icon" type="image/png" href="https://dihad.github.io/Repeating-Decimal-Operations/web%20icon.jpeg" />

  <!-- math.js (expression parsing & numeric evaluation) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>

  <!-- MathJax for rendering math (keeps UI nice) -->
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    :root{
      --bg: #0b1220;
      --card: rgba(255,255,255,0.04);
      --muted: #9fb1bf;
      --accent: #6ee7b7;
      --accent-2: #60a5fa;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    html,body {
      height:100%;
      margin:0;
      background:linear-gradient(180deg,#090c16 0%, #02060c 100%);
      color:#e6eef3;
      -webkit-font-smoothing:antialiased;
    }

    .container {
      max-width:1000px;
      margin:20px auto;
      padding:18px;
      display:flex;
      flex-direction:column;
      gap:18px;
    }

    header { display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap; gap:12px; }
    .brand { display:flex; align-items:baseline; gap:12px; }
    h1 { margin:0; color:var(--accent-2); font-size:1.6rem; }
    .subtitle { color:var(--muted); font-size:0.95rem; }

    .grid { display:grid; grid-template-columns:1fr 360px; gap:18px; }
    @media (max-width:920px){ .grid { grid-template-columns:1fr; } }

    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:16px;
      box-shadow:0 10px 30px rgba(2,6,12,0.6);
      border:1px solid rgba(255,255,255,0.02);
    }

    label { display:block; font-size:13px; color:var(--muted); margin-bottom:8px; }
    input[type=text], select, textarea {
      width:100%;
      padding:12px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.04);
      background:transparent;
      color:inherit;
      font-size:15px;
      outline:none;
    }

    .controls { display:flex; gap:8px; margin-top:10px; flex-wrap:wrap; }
    button {
      background: linear-gradient(180deg,var(--accent), var(--accent-2));
      border:none; padding:10px 14px; border-radius:10px; color:#022; cursor:pointer; font-weight:700;
      box-shadow:0 6px 18px rgba(96,165,250,0.08);
    }
    .btn-ghost { background:transparent; border:1px solid rgba(255,255,255,0.04); color:var(--muted); font-weight:600; }

    .muted { color:var(--muted); font-size:13px; }
    .result-block { margin-top:12px; padding:14px; border-radius:10px; background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.02); }
    pre { white-space:pre-wrap; margin:6px 0; font-size:13px; color:#d7f0fb; background:transparent; }

    .small { font-size:13px; color:var(--muted); }

    footer { display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap; color:var(--muted); font-size:13px; padding:12px 0; }
    .logo-pill { padding:6px 10px; border-radius:999px; background:rgba(255,255,255,0.02); color:var(--muted); font-weight:600; font-size:13px; }

    @media (max-width:420px){
      h1 { font-size:1.25rem; }
      .card { padding:12px; }
      button { padding:10px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="brand">
        <h1>1.2 functions</h1>
        <div class="subtitle">Domain · Range · Injective · Onto</div>
      </div>
      <div class="logo-pill"> — Developed by Dihad Hasan 2025</div>
    </header>

    <div class="grid">
      <main class="card">
        <label for="expr">Function of <code>x</code> — examples: <span class="muted">(2x+1)/(2x-1), x^3, sqrt(x), sin(x)</span></label>
        <input id="expr" type="text" placeholder="e.g. (2x+1)/(2x-1)" value="(2x+1)/(2x-1)">

        <div style="display:flex; gap:10px; margin-top:12px; flex-wrap:wrap;">
          <div style="flex:1;">
            <label for="codomain">Codomain (examples: <code>R</code>, <code>R - 1</code>, <code>R - {1}</code>)</label>
            <input id="codomain" type="text" placeholder="R" value="R">
            <div class="muted" style="margin-top:6px">Type <code>R</code> for ℝ, or <code>R - 1</code> / <code>R - {1}</code> for ℝ \ {1}.</div>
          </div>
        </div>

        <div class="controls" style="margin-top:12px;">
          <button id="computeBtn">Analyze</button>
          <button id="clearBtn" class="btn-ghost">Clear</button>
        </div>

        <div id="results" class="result-block">
          <div class="small">Results will appear here after analysis.</div>
        </div>
      </main>

      <aside class="card">
        <div style="display:flex;align-items:center;justify-content:space-between">
          <div style="font-weight:700">Quick info</div>
          <div class="muted" style="font-size:12px">Function analyzer</div>
        </div>

        <hr>

        <div class="small" style="margin-bottom:8px">
          Enter a mathematical expression using <code>x</code>. For codomain examples:
          <ul style="margin:8px 0 0 16px; color:var(--muted); padding:0;">
            <li><code>R</code> — all real numbers (renders as ℝ).</li>
            <li><code>R - 1</code> or <code>R - {1}</code> — means ℝ \ {1}.</li>
          </ul>
        </div>

        <hr>

        <div class="small"><strong>Tips</strong>
          <ol style="margin:8px 0 0 16px; color:var(--muted);">
            <li>Use parentheses for fractions: <code>(2x+1)/(2x-1)</code>.</li>
            <li>Square root: <code>sqrt(x)</code> or <code>x^(1/2)</code>.</li>
            <li>Raise to powers with <code>^</code> or <code>pow(base,expo)</code>: <code>x^2</code>, <code>(x+1)^3</code>, <code>2^(x+1)</code>.</li>
            <li>Implicit multiplication works: <code>2x</code> ≡ <code>2*x</code>. Use parentheses when needed: <code>2(x+1)</code>.</li>
            <li>Trig and logs: <code>sin(x)</code>, <code>cos(x)</code>, <code>log(x)</code> (natural), <code>log(x,10)</code> (base 10).</li>
            <li>Codomain exclusions: <code>R - {1,2}</code> or <code>R - 1</code>.</li>
            <li>Decimals & fractions are allowed: <code>1/3</code>, <code>0.333</code>.</li>
          </ol>
        </div>
      </aside>
    </div>

    <footer>
      <div>Developed by Dihad 2025</div>
      <div class="muted"></div>
    </footer>
  </div>

  <script>
    /* helpers and small utilities */
    const $ = selector => document.querySelector(selector);

    function isRealNumber(v) {
      return typeof v === 'number' && Number.isFinite(v);
    }

    function escapeHtml(unsafe) {
      if (unsafe === null || unsafe === undefined) return '';
      return String(unsafe)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    function preprocess(input) {
      if (!input || typeof input !== 'string') return input || '';
      let s = input.trim();
      s = s.replace(/×/g, '*').replace(/÷/g, '/').replace(/[−–—]/g, '-');
      s = s.replace(/\s+/g, ' ');
      s = s.replace(/(\d|\))\s*(?=[a-zA-Z(])/g, '$1*');
      s = s.replace(/([a-zA-Z\)])\s*(?=\d|\()/g, '$1*');
      s = s.replace(/([a-zA-Z])\s+([a-zA-Z])/g, '$1*$2');
      s = s.replace(/\+\+/g, '+').replace(/--/g, '+').replace(/\+\-/g, '-').replace(/\-\+/g, '-');
      return s;
    }

    function prettyNumber(val) {
      if (!isRealNumber(val)) return String(val);
      if (Math.abs(val - Math.round(val)) < 1e-9) return `${Math.round(val)}`;
      try {
        const frac = math.fraction(val);
        if (Math.abs(frac.valueOf() - val) < 1e-12) {
          return `\\frac{${frac.n}}{${frac.d}}`;
        }
      } catch (e) {}
      return (+val.toFixed(8)).toString();
    }

    /* symbolic detection of linear-fraction (a1 x + b1) / (a2 x + b2) */
    function getLinearCoeffs(exprStr) {
      try {
        const compiled = math.compile(exprStr);
        const y0 = compiled.evaluate({ x: 0 });
        const y1 = compiled.evaluate({ x: 1 });
        const y2 = compiled.evaluate({ x: 2 });
        if (!isRealNumber(y0) || !isRealNumber(y1) || !isRealNumber(y2)) return null;
        const a = y1 - y0;
        const b = y0;
        if (Math.abs((a * 2 + b) - y2) < 1e-6) return { a: +a, b: +b };
      } catch (e) { /* parsing/eval failed */ }
      return null;
    }

    function detectLinearFraction(node) {
      if (!node || !node.isOperatorNode || node.op !== '/') return null;
      const left = node.args[0], right = node.args[1];
      const leftStr = left.toString();
      const rightStr = right.toString();
      const L = getLinearCoeffs(leftStr);
      const R = getLinearCoeffs(rightStr);
      if (L && R) return { a1: L.a, b1: L.b, a2: R.a, b2: R.b, leftStr, rightStr };
      return null;
    }

    /* numeric evaluation helper with fixed sampling range */
    function tryEval(compiled, x) {
      try {
        const y = compiled.evaluate({ x });
        if (typeof y === 'object' && y !== null && ('re' in y)) {
          if (Math.abs(y.im || 0) > 1e-9) return { ok: false };
          return { ok: true, y: y.re };
        }
        if (isRealNumber(y)) return { ok: true, y };
        return { ok: false };
      } catch (e) {
        return { ok: false };
      }
    }

    /* parse codomain text and extract R-style exclusions */
    function parseCodomain(text) {
      const raw = (text || '').trim();
      if (!raw) return { type: 'other', raw, latex: '' };

      const t = raw.replace(/\s+/g, ' ').trim();
      const Rmatch = /^R\b/i.test(t) || /\\mathbb\{R\}/.test(t) || /ℝ/.test(t);
      if (!Rmatch) return { type: 'other', raw: t, latex: escapeHtml(t) };

      let excluded = [];
      const dashMatch = t.match(/R\s*-\s*(\{?.+\}?)/i);
      if (dashMatch && dashMatch[1]) {
        let body = dashMatch[1].trim();
        body = body.replace(/^\{/, '').replace(/\}$/, '').trim();
        const parts = body.split(',').map(s => s.trim()).filter(Boolean);
        for (const p of parts) {
          try {
            const v = math.evaluate(p);
            if (isRealNumber(v)) excluded.push(+v);
          } catch (e) {}
        }
      } else {
        const setminusMatch = t.match(/setminus\s*\{?([^\}]+)\}?/i);
        if (setminusMatch && setminusMatch[1]) {
          const parts = setminusMatch[1].split(',').map(s => s.trim());
          for (const p of parts) {
            try {
              const v = math.evaluate(p);
              if (isRealNumber(v)) excluded.push(+v);
            } catch (e) {}
          }
        }
      }

      let latex = '\\mathbb{R}';
      if (excluded.length) {
        const items = excluded.map(v => prettyNumber(v)).join(', ');
        latex = `\\mathbb{R} \\setminus \\{ ${items} \\}`;
      }
      return { type: 'R', raw: t, excluded, latex };
    }

    /* injectivity heuristic from sampled points */
    function checkInjective(xs, ys) {
      if (ys.length < 5) return { injective: false, reason: 'insufficient samples' };
      let inc = true, dec = true;
      for (let i = 1; i < ys.length; i++) {
        if (ys[i] <= ys[i - 1] + 1e-9) inc = false;
        if (ys[i] >= ys[i - 1] - 1e-9) dec = false;
      }
      if (inc || dec) return { injective: true, reason: 'monotonic across sampled domain' };

      const seen = {};
      for (let i = 0; i < ys.length; i++) {
        const key = Math.round(ys[i] * 1e6);
        if (seen[key] !== undefined && Math.abs(seen[key] - xs[i]) > 1e-6) {
          return { injective: false, reason: 'same y for different sampled x' };
        }
        seen[key] = xs[i];
      }
      return { injective: true, reason: 'no collisions in sampled points (heuristic)' };
    }

    /* helper to wrap LaTeX for MathJax */
    function latexWrap(latexString) {
      if (!latexString || String(latexString).trim() === '') return '';
      return `\\(${latexString}\\)`;
    }

    /* UI elements */
    const inputEl = $('#expr');
    const codomainEl = $('#codomain');
    const computeBtn = $('#computeBtn');
    const clearBtn = $('#clearBtn');
    const resultsEl = $('#results');

    clearBtn.addEventListener('click', () => {
      inputEl.value = '';
      codomainEl.value = 'R';
      resultsEl.innerHTML = '<div class="small">Cleared — enter a function and press Analyze.</div>';
      if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise();
    });

    computeBtn.addEventListener('click', async () => {
      const rawInput = (inputEl.value || '').trim();
      const codomainText = (codomainEl.value || '').trim();

      if (!rawInput) {
        resultsEl.innerHTML = '<div class="small">Enter a function.</div>';
        return;
      }

      resultsEl.innerHTML = `<div class="small">Parsing and analyzing…</div>`;

      const expr = preprocess(rawInput);

      let parsedNode;
      try {
        parsedNode = math.parse(expr);
      } catch (err) {
        resultsEl.innerHTML = `<div class="small" style="color:#ffd3a3"><strong>Parse error:</strong> ${escapeHtml(err.message)}<br>Attempted expression: <pre>${escapeHtml(expr)}</pre></div>`;
        if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise();
        return;
      }

      const codomainObj = parseCodomain(codomainText);

      /* Symbolic path: detect linear fractional (Mobius) function */
      const lf = detectLinearFraction(parsedNode);
      if (lf) {
        const { a1, b1, a2, b2 } = lf;

        let domainLatex;
        if (Math.abs(a2) > 1e-12) {
          const root = -b2 / a2;
          domainLatex = `\\mathbb{R} \\setminus \\{ ${prettyNumber(root)} \\}`;
        } else {
          domainLatex = (Math.abs(b2) < 1e-12) ? '\\varnothing' : '\\mathbb{R}';
        }

        let rangeLatex;
        let excludedVal = null;
        if (Math.abs(a2) > 1e-12) {
          excludedVal = a1 / a2;
          rangeLatex = `\\mathbb{R} \\setminus \\{ ${prettyNumber(excludedVal)} \\}`;
        } else {
          rangeLatex = '\\mathbb{R}';
        }

        const inverseLatex = `f^{-1}(x) = \\dfrac{ ${prettyNumber(b1)} - ${prettyNumber(b2)} x }{ ${prettyNumber(a2)} x - ${prettyNumber(a1)} }`;
        const injectiveText = 'Yes (one-to-one on its domain)';

        let ontoFlag = false;
        let ontoReason = '';

        if (codomainObj.type === 'R') {
          if (rangeLatex.includes('setminus')) {
            if (codomainObj.excluded.length === 0) {
              ontoFlag = false;
              ontoReason = `Range is ${rangeLatex} which excludes ${prettyNumber(excludedVal)}, so not onto \\(\\mathbb{R}\\).`;
            } else {
              const match = codomainObj.excluded.some(e => Math.abs(e - excludedVal) < 1e-9);
              if (match && codomainObj.excluded.length === 1) {
                ontoFlag = true;
                ontoReason = `Range excludes exactly ${prettyNumber(excludedVal)}, matching codomain exclusion — onto the specified codomain.`;
              } else {
                ontoFlag = false;
                ontoReason = `Range excludes ${prettyNumber(excludedVal)} but codomain excludes ${codomainObj.excluded.join(', ')} — they don't match.`;
              }
            }
          } else {
            if (codomainObj.excluded.length === 0) {
              ontoFlag = true;
              ontoReason = 'Range covers all ℝ — onto.';
            } else {
              ontoFlag = false;
              ontoReason = `Range is ℝ but codomain excludes ${codomainObj.excluded.join(', ')} — not onto the specified codomain.`;
            }
          }
        } else {
          ontoFlag = false;
          ontoReason = 'Codomain not recognized as ℝ-style; symbolic onto-check only supports ℝ-style codomains.';
        }

        const html = [
          `<div class="small"><strong>Original input:</strong> <code>${escapeHtml(rawInput)}</code></div>`,
          `<div class="small"><strong>Interpreted:</strong> <pre>${escapeHtml(expr)}</pre></div>`,
          `<div style="margin-top:8px"><strong>Detected form:</strong> \\(\\dfrac{a_1 x + b_1}{a_2 x + b_2}\\) with \\(a_1=${prettyNumber(a1)},\\; b_1=${prettyNumber(b1)},\\; a_2=${prettyNumber(a2)},\\; b_2=${prettyNumber(b2)}\\)</div>`,
          `<div style="margin-top:8px"><strong>Domain (exact):</strong> ${latexWrap(domainLatex)}</div>`,
          `<div style="margin-top:8px"><strong>Range (exact):</strong> ${latexWrap(rangeLatex)}</div>`,
          `<div style="margin-top:8px"><strong>Inverse function (exact):</strong> ${latexWrap(inverseLatex)}</div>`,
          `<div style="margin-top:8px"><strong>Injective (one-one)?</strong> ${escapeHtml(injectiveText)}</div>`,
          `<div style="margin-top:8px"><strong>Codomain specified:</strong> ${latexWrap(codomainObj.latex)}</div>`,
          `<div style="margin-top:8px"><strong>Onto (surjective to specified codomain)?</strong> ${ontoFlag ? '<strong style="color:#6ee7b7">Yes</strong>' : '<strong style="color:#ffd3a3">No</strong>'} <div class="small muted" style="margin-top:6px">${escapeHtml(ontoReason)}</div></div>`
        ].join('');

        resultsEl.innerHTML = html;
        if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise();
        return;
      }

      /* numeric fallback path (sampling) */
      try {
        const compiled = math.compile(expr);
        const xmin = -50, xmax = 50, step = 0.5;
        const xs = [];
        const ys = [];

        for (let x = xmin; x <= xmax + 1e-12; x = +(x + step).toFixed(12)) {
          const r = tryEval(compiled, x);
          if (r.ok) { xs.push(x); ys.push(r.y); }
        }

        let rangeLatex = '\\varnothing';
        if (ys.length) {
          const minY = Math.min(...ys), maxY = Math.max(...ys);
          rangeLatex = `\\left[ ${(+minY.toFixed(6))},\\; ${(+maxY.toFixed(6))} \\right] \\text{ (approx)}`;
        }

        const inj = checkInjective(xs, ys);

        let ontoFlag = false;
        let ontoReason = '';

        if (codomainObj.type === 'R') {
          if (!ys || ys.length < 6) {
            ontoFlag = false;
            ontoReason = 'Insufficient numeric samples to determine onto.';
          } else {
            const span = Math.abs(Math.max(...ys) - Math.min(...ys));
            if (codomainObj.excluded.length === 0) {
              if (span > 100) {
                ontoFlag = true;
                ontoReason = 'Sampled range is wide — heuristically covers ℝ (approx).';
              } else {
                ontoFlag = false;
                ontoReason = `Sampled numeric range appears finite (span ≈ ${span.toFixed(3)}) — unlikely onto ℝ.`;
              }
            } else {
              const tol = Math.max(1e-3, span * 1e-6);
              let allExcludedMissing = true;
              for (const ex of codomainObj.excluded) {
                const near = ys.some(v => Math.abs(v - ex) < tol);
                if (near) { allExcludedMissing = false; break; }
              }
              if (allExcludedMissing && span > 50) {
                ontoFlag = true;
                ontoReason = `Samples avoid excluded values (${codomainObj.excluded.join(',')}) and show wide coverage — heuristically onto.`;
              } else {
                ontoFlag = false;
                ontoReason = `Either samples contain excluded values or coverage not wide enough (span=${span.toFixed(3)}) — not confidently onto.`;
              }
            }
          }
        } else {
          ontoFlag = false;
          ontoReason = 'Codomain not recognized as ℝ-style; numeric onto-check limited.';
        }

        const html = [
          `<div class="small"><strong>Original input:</strong> <code>${escapeHtml(rawInput)}</code></div>`,
          `<div class="small"><strong>Interpreted:</strong> <pre>${escapeHtml(expr)}</pre></div>`,
          `<div style="margin-top:8px"><strong>Domain (approx):</strong> Numeric sampling over [${xmin}, ${xmax}] (step ${step})</div>`,
          `<div style="margin-top:8px"><strong>Range (approx):</strong> ${latexWrap(rangeLatex)}</div>`,
          `<div style="margin-top:8px"><strong>Injective (one-one)?</strong> ${inj.injective ? '<strong style="color:#6ee7b7">Likely yes</strong>' : '<strong style="color:#ffd3a3">Likely no</strong>'} <div class="small muted" style="margin-top:6px">${escapeHtml(inj.reason)}</div></div>`,
          `<div style="margin-top:8px"><strong>Codomain specified:</strong> ${latexWrap(codomainObj.latex)}</div>`,
          `<div style="margin-top:8px"><strong>Onto (surjective to specified codomain)?</strong> ${ontoFlag ? '<strong style="color:#6ee7b7">Likely yes</strong>' : '<strong style="color:#ffd3a3">Likely no</strong>'} <div class="small muted" style="margin-top:6px">${escapeHtml(ontoReason)}</div></div>`
        ].join('');

        resultsEl.innerHTML = html;
        if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise();
        return;
      } catch (err) {
        resultsEl.innerHTML = `<div class="small" style="color:#ffd3a3"><strong>Error:</strong> ${escapeHtml(err && err.message ? err.message : String(err))}</div>`;
        if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise();
        return;
      }
    });
  </script>
</body>
</html>
